"""
Telegram bot implementation for employee knowledge base.
Handles user interactions and provides answers from Google Sheets.
"""

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ContextTypes
from typing import List, Dict
import asyncio
from datetime import datetime

from .sheets_manager import CSVManager
from .question_matcher import QuestionMatcher

logger = logging.getLogger(__name__)

class TelegramBot:
    """Main Telegram bot class."""
    
    def __init__(self, config):
        """Initialize the Telegram bot."""
        self.config = config
        self.csv_manager = CSVManager(config)
        self.question_matcher = QuestionMatcher(config)
        self.application = None
        self._setup_bot()
    
    def _setup_bot(self):
        """Setup the Telegram bot application."""
        try:
            # Create application
            self.application = Application.builder().token(self.config.telegram_token).build()
            
            # Add handlers
            self.application.add_handler(CommandHandler("start", self.start_command))
            self.application.add_handler(CommandHandler("help", self.help_command))
            self.application.add_handler(CommandHandler("categories", self.categories_command))
            self.application.add_handler(CommandHandler("stats", self.stats_command))
            self.application.add_handler(CommandHandler("refresh", self.refresh_command))
            
            # Callback query handler for buttons
            self.application.add_handler(CallbackQueryHandler(self.button_callback))
            
            # Message handler for questions
            self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_question))
            
            logger.info("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–æ—Ç–∞ Telegram –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
            
        except Exception as e:
            logger.error(f"Failed to setup Telegram bot: {str(e)}")
            raise
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command."""
        welcome_message = """

–ü—Ä–∏–≤–µ—Ç!–Ø Volticü§ñ- —Ç–≤–æ–π —Ü–∏—Ñ—Ä–æ–≤–æ–π –Ω–∞–ø–∞—Ä–Ω–∏–∫-—ç–ª–µ–∫—Ç—Ä–æ–º–æ–Ω—Ç–µ—Ä! ‚ú®

**–ö–∞–∫ —Å–æ –º–Ω–æ–π —Ä–∞–±–æ—Ç–∞—Ç—å:**
‚Ä¢ –ü—Ä–æ—Å—Ç–æ –≤–≤–µ–¥–∏ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å, –∏ —è –ø–æ–∏—â—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –Ω–∞—à–µ–π –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π.
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /categories, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–µ–º—ã.
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.

**–ù–∞–ø—Ä–∏–º–µ—Ä:**
‚Ä¢ "–ù–∞–ø–∏—à–∏ –º–Ω–µ –∑–∞–∫–æ–Ω –û–ú–ê"
‚Ä¢ "–ö–∞–∫ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å–∏–ª—É —Ç–æ–∫–∞?"
‚Ä¢ "–ö–∞–∫–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ –≤ –¥–æ–º–∞—à–Ω–µ–π —Ä–æ–∑–µ—Ç–∫–µ?"

–î–∞–≤–∞–π –ø–æ–ø—Ä–æ–±—É–µ–º, —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ!  üöÄ
        """
        
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command."""
        help_message = """
üìö **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**

/start - –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏;
/help - —Å–ø—Ä–∞–≤–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ;
/categories - —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π;
/stats - –ø–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π;
/refresh - –æ–±–Ω–æ–≤–∏—Ç—å –∫—ç—à –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π.

**–ö–∞–∫ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã:**
–ü—Ä–æ—Å—Ç–æ –≤–≤–µ–¥–∏—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –≤ –ø–æ–ª–µ –¥–ª—è –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞! –Ø –Ω–∞–π–¥—É –Ω–∞–∏–±–æ–ª–µ–µ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã, –∏—Å–ø–æ–ª—å–∑—É—è –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è.

**–°–æ–≤–µ—Ç—ã –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –Ω–∞–∏–ª—É—á—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:**
‚Ä¢ –ó–∞–¥–∞–≤–∞–π—Ç–µ —á–µ—Ç–∫–∏–µ –∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã;
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞;
‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–∏–µ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏, –µ—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω—ã.

**–ü—Ä–∏–º–µ—Ä—ã –≤–æ–ø—Ä–æ—Å–æ–≤:**
‚Ä¢ "–ù–∞–ø–∏—à–∏ –∑–∞–∫–æ–Ω –û–º–∞";
‚Ä¢ "–§–æ—Ä–º—É–ª–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –º–æ—â–Ω–æ—Å—Ç–∏ —ç–ª–µ–∫—Ç—Ä–æ–¥–≤–∏–≥–∞—Ç–µ–ª—è";
‚Ä¢ "–ö–∞–∫–∞—è –¥–æ–ø—É—Å—Ç–∏–º–∞—è –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∞ —ç–ª–µ–∫—Ç—Ä–æ–¥–≤–∏–≥–∞—Ç–µ–ª—è?".

–ï—Å–ª–∏ –í—ã –Ω–µ –Ω–∞—à–ª–∏ —Ç–æ, —á—Ç–æ –∏—Å–∫–∞–ª–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –∏ —è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–º–æ–≥—É –í–∞–º!
        """
        
        await update.message.reply_text(help_message, parse_mode='Markdown')
    
    async def categories_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /categories command."""
        try:
            knowledge_base = self.csv_manager.get_knowledge_base()
            categories = self.question_matcher.get_categories(knowledge_base)
            
            if not categories:
                await update.message.reply_text("–ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")
                return
            
            # Create inline keyboard with categories
            keyboard = []
            for i in range(0, len(categories), 2):
                row = [InlineKeyboardButton(categories[i], callback_data=f"cat_{categories[i]}")]
                if i + 1 < len(categories):
                    row.append(InlineKeyboardButton(categories[i + 1], callback_data=f"cat_{categories[i + 1]}"))
                keyboard.append(row)
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            message = "üìã **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:**\n\n–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—é, —á—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–æ–ø—Ä–æ—Å—ã:"
            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error in categories command: {str(e)}")
            await update.message.reply_text("–ò–∑–≤–∏–Ω–∏—Ç–µ, –º–Ω–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    
    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /stats command."""
        try:
            stats = self.csv_manager.get_stats()
            
            if "error" in stats:
                await update.message.reply_text("–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ —Å–º–æ–≥ —Å–µ–π—á–∞—Å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.")
                return
            
            message = f"""
üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π:**

‚Ä¢ –í—Å–µ–≥–æ –≤–æ–ø—Ä–æ—Å–æ–≤: {stats.get('total_questions', 0)}
‚Ä¢ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏: {stats.get('categories', 0)}
‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {stats.get('last_updated', 'Unknown')}

**–†–∞–∑–±–∏–≤–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:**
            """
            
            if "category_breakdown" in stats:
                for category, count in stats["category_breakdown"].items():
                    message += f"‚Ä¢ {category}: {count} –≤–æ–ø—Ä–æ—Å\n"
            
            await update.message.reply_text(message, parse_mode='Markdown')
            
        except Exception as e:
            logger.error(f"Error in stats command: {str(e)}")
            await update.message.reply_text("–ò–∑–≤–∏–Ω–∏—Ç–µ, –º–Ω–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    
    async def refresh_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /refresh command."""
        try:
            await update.message.reply_text("üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π...")
            
            self.csv_manager.refresh_cache()
            
            await update.message.reply_text("‚úÖ Knowledge base refreshed successfully!")
            
        except Exception as e:
            logger.error(f"Error in refresh command: {str(e)}")
            await update.message.reply_text("‚ùå Failed to refresh knowledge base. Please try again later.")
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle button callbacks."""
        query = update.callback_query
        await query.answer()
        
        try:
            data = query.data
            
            if data.startswith("cat_"):
                # Category selection
                category = data[4:]  # Remove "cat_" prefix
                
                knowledge_base = self.csv_manager.get_knowledge_base()
                category_questions = knowledge_base[
                    knowledge_base['Category'].str.lower() == category.lower()
                ]
                
                if category_questions.empty:
                    await query.edit_message_text(f"No questions found in category: {category}")
                    return
                
                # Show questions in this category
                message = f"üìã **Questions in {category}:**\n\n"
                
                for idx, row in category_questions.head(10).iterrows():
                    message += f"‚Ä¢ {row['Question']}\n"
                
                if len(category_questions) > 10:
                    message += f"\n... and {len(category_questions) - 10} more questions"
                
                message += "\n\nJust type your question to get an answer!"
                
                await query.edit_message_text(message, parse_mode='Markdown')
                
        except Exception as e:
            logger.error(f"Error in button callback: {str(e)}")
            await query.edit_message_text("Sorry, something went wrong. Please try again.")
    
    async def handle_question(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle user questions."""
        user_question = update.message.text
        user_id = update.effective_user.id
        username = update.effective_user.username or "Unknown"
        
        logger.info(f"Question from user {username} ({user_id}): {user_question}")
        
        try:
            # Get knowledge base
            knowledge_base = self.csv_manager.get_knowledge_base()
            
            if knowledge_base.empty:
                await update.message.reply_text(
                    "Sorry, the knowledge base is currently empty. Please try again later or contact support."
                )
                return
            
            # Find matches
            matches = self.question_matcher.find_matches(user_question, knowledge_base)
            
            if not matches:
                # No matches found
                await self._send_no_matches_response(update, user_question)
                return
            
            # Send the best match
            best_match = matches[0]
            await self._send_answer(update, best_match, len(matches))
            
            # If there are multiple good matches, offer alternatives
            if len(matches) > 1:
                await self._send_alternative_answers(update, matches[1:])
                
        except Exception as e:
            logger.error(f"Error handling question: {str(e)}")
            await update.message.reply_text(
                "Sorry, I encountered an error while searching for your answer. Please try again later."
            )
    
    async def _send_answer(self, update: Update, match: Dict, total_matches: int):
        """Send the answer to the user."""
        answer_message = f"""
üéØ **–í–æ—Ç —á—Ç–æ –º–Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏!** (Score: {match['score']}%)

**–¢–≤–æ–π –≤–æ–ø—Ä–æ—Å:** {match['question']}

**–ù–∞–π–¥–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç:** {match['answer']}

**–ö–∞—Ç–µ–≥–æ—Ä–∏—è:** {match['category']}
        """
        
        if total_matches > 1:
            answer_message += f"\nüí° Found {total_matches} related answers"
        
        await update.message.reply_text(answer_message, parse_mode='Markdown')
    
    async def _send_alternative_answers(self, update: Update, alternatives: List[Dict]):
        """Send alternative answers if available."""
        if not alternatives:
            return
        
        alt_message = "üîç **–î—Ä—É–≥–∏–µ –ø–æ—Ö–æ–∂–∏–µ –æ—Ç–≤–µ—Ç—ã:**\n\n"
        
        for i, alt in enumerate(alternatives[:3], 1):  # Show max 3 alternatives
            alt_message += f"**{i}.** {alt['question']}\n"
            alt_message += f"*Score: {alt['score']}%*\n\n"
        
        alt_message += "–í–≤–µ–¥–∏—Ç–µ –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –≤–æ–ø—Ä–æ—Å, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—á–Ω—ã–π –æ—Ç–≤–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤–∞–º –Ω—É–∂–µ–Ω!"
        
        await update.message.reply_text(alt_message, parse_mode='Markdown')
    
    async def _send_no_matches_response(self, update: Update, user_question: str):
        """Send response when no matches are found."""
        no_match_message = f"""
ü§î **–•–º–º–º...–ß—Ç–æ-—Ç–æ —è –Ω–µ —Å–º–æ–≥ –Ω–∞–π—Ç–∏ —Ö–æ—Ä–æ—à–∏–π –æ—Ç–≤–µ—Ç –Ω–∞ —Ç–≤–æ–π –≤–æ–ø—Ä–æ—Å: "{user_question}"**

**üëâ–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:**
‚Ä¢ –ü–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä—É–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å, –∏—Å–ø–æ–ª—å–∑—É—è –¥—Ä—É–≥–∏–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞;
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–µ—Ä–º–∏–Ω—ã;
‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å –ø–æ–º–æ—â—å—é /categories.
        """
        
        await update.message.reply_text(no_match_message, parse_mode='Markdown')
    
    async def run(self):
        """Start the bot."""
        try:
            logger.info("Starting Telegram bot...")
            
            # Start the bot
            await self.application.initialize()
            await self.application.start()
            
            # Start polling
            await self.application.updater.start_polling(
                allowed_updates=Update.ALL_TYPES,
                drop_pending_updates=True
            )
            
            logger.info("Bot is running and polling for updates...")
            
            # Keep the bot running
            import signal
            import asyncio
            
            # Create a future that will be resolved when a signal is received
            stop_signals = (signal.SIGTERM, signal.SIGINT)
            loop = asyncio.get_running_loop()
            
            for sig in stop_signals:
                loop.add_signal_handler(sig, lambda s=sig: loop.stop())
            
            # Run until stopped
            try:
                await asyncio.Event().wait()
            except asyncio.CancelledError:
                pass
            
        except Exception as e:
            logger.error(f"Error running bot: {str(e)}")
            raise
        finally:
            # Cleanup
            await self.application.stop()
            await self.application.shutdown()
